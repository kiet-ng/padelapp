<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- Prevent iOS auto-zoom; fit the notch; keep scale steady -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <title>Americano – Live Round & Leaderboard (v15)</title>
  <style>
    :root{ --bg:#0b0f14; --card:#0f172a; --border:#1f2937; --muted:#9aa4b2; --fg:#e7ecf3; }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
    html{-webkit-text-size-adjust:100%}
    .wrap{max-width:960px;margin:0 auto;padding:16px}
    .bar{position:sticky;top:0;background:rgba(11,15,20,.92);backdrop-filter:blur(8px);border-bottom:1px solid var(--border);z-index:10;
         padding-top:env(safe-area-inset-top)}
    .bar .wrap{display:flex;gap:10px;align-items:center}
    .pill{font-size:12px;color:var(--muted);border:1px solid var(--border);padding:4px 10px;border-radius:999px}
    .btn{display:inline-flex;align-items:center;gap:6px;padding:12px 16px;border-radius:12px;border:1px solid #334155;background:#22c55e;color:#0b1118;
         font-weight:700;cursor:pointer;touch-action:manipulation}
    .btn.ghost{background:var(--card);color:var(--fg);border-color:#334155}
    .btn.danger{background:#7f1d1d;border-color:#7f1d1d;color:#fecaca}
    .btn.alt{background:#f59e0b;border-color:#f59e0b;color:#111827}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:16px;margin:14px 0}
    label{display:block;margin:12px 0 6px;font-size:14px;color:var(--muted)}
    textarea,input,select{
      width:100%;padding:12px 12px;border-radius:10px;border:1px solid #334155;background:#0b1220;color:var(--fg);
      font-size:16px;line-height:1.2; -webkit-appearance:none; appearance:none;
    }
    textarea{min-height:120px;resize:vertical}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid #334155;padding:10px 8px;text-align:left}
    .hidden{display:none}
    #error{display:none;background:#3f1d20;border:1px solid #7f1d1d;color:#fecaca;border-radius:10px;padding:10px;margin-top:10px;white-space:pre-wrap}
    .tags{display:flex;gap:8px;flex-wrap:wrap}
    .muted{color:var(--muted)}
    .match{padding:12px;margin:12px 0;border:1px dashed #334155;border-radius:12px}
    .score{ display:grid;grid-template-columns:auto 1fr auto 1fr;gap:10px;align-items:center;margin-top:10px }
    .score input{ width:100%;max-width:140px;text-align:center;font-weight:700;padding:12px 10px }
    @media (max-width:520px){
      .wrap{padding:12px}
      .btn{padding:12px 14px}
      .score{grid-template-columns:1fr 1fr;grid-row-gap:8px}
      .score > :nth-child(1){grid-column:1;justify-self:start}
      .score > :nth-child(2){grid-column:2}
      .score > :nth-child(3){grid-column:1;justify-self:start}
      .score > :nth-child(4){grid-column:2}
    }
  </style>
  <script>
    window.addEventListener('error', e => {
      const box = document.getElementById('error');
      if(!box) return;
      box.style.display = 'block';
      box.textContent = 'JS error: ' + (e.message || e.error || 'unknown');
    });
  </script>
</head>
<body>
  <div class="bar">
    <div class="wrap">
      <h2 style="margin:0">Kiet's Americano App</h2>
      <span class="pill" id="status">ready</span>
      <div style="flex:1"></div>
      <button id="btnLeaderboard" class="btn ghost" disabled>Leaderboard</button>
      <button id="btnResetKeep" class="btn alt">Reset (keep players)</button>
      <button id="btnReset" class="btn danger">Reset</button>
    </div>
  </div>

  <div class="wrap">
    <div id="error"></div>

    <div id="setupCard" class="card">
      <h3>Setup</h3>
      <label>Players (one per line)</label>
      <textarea id="players" placeholder="Alice&#10;Bjørn&#10;Carla&#10;David&#10;Emma&#10;Filip&#10;Grete&#10;Henrik&#10;Iris"></textarea>

      <label>Courts</label>
      <input id="courts" type="number" value="2" min="1" inputmode="numeric" />

      <label>Points per match</label>
      <select id="points">
        <option value="16">16</option>
        <option value="20">20</option>
        <option value="24" selected>24</option>
        <option value="32">32</option>
      </select>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px">
        <div>
          <label>Total rounds mode</label>
          <select id="roundsMode">
            <option value="auto" selected>Auto (full cycle)</option>
            <option value="equal">Equal (balanced)</option>
            <option value="custom">Custom number</option>
            <option value="unlimited">Unlimited</option>
          </select>
        </div>

        <div id="equalWrap" class="hidden">
          <label>Equal round count</label>
          <select id="equalRounds"></select>
          <div id="equalNote" class="muted" style="font-size:13px;margin-top:6px"></div>
        </div>

        <div id="customRoundsWrap" class="hidden">
          <label>Total rounds (custom)</label>
          <input id="customRounds" type="number" min="1" value="9" inputmode="numeric" />
        </div>
      </div>

      <button class="btn" id="start" style="margin-top:14px">Start event</button>
    </div>

    <div id="roundCard" class="card hidden">
      <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
        <h3 id="roundTitle" style="margin:0">Round</h3>
        <div class="tags">
          <span class="pill" id="roundCount"></span>
          <span class="pill" id="pointsInfo"></span>
          <span class="pill hidden" id="sitInfo"></span>
        </div>
        <div style="flex:1"></div>
        <button class="btn ghost" id="prev">◀ Prev</button>
        <button class="btn ghost" id="next">Next ▶</button>
      </div>
      <div id="matches"></div>
      <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:10px">
        <button class="btn" id="submit">Submit round scores</button>
      </div>
    </div>

    <div id="leaderCard" class="card hidden">
      <div style="display:flex;align-items:center;gap:10px">
        <h3 style="margin:0">Leaderboard</h3>
        <div style="flex:1"></div>
        <button class="btn ghost" id="closeLeader">Back to round</button>
      </div>
      <table id="leader"><tr><th>#</th><th>Player</th><th class="muted">Record</th><th>Points</th></tr></table>
    </div>
  </div>

<script>
const $=s=>document.querySelector(s); const $$=s=>Array.from(document.querySelectorAll(s));
const state={names:[],courts:2,points:24,rounds:[],cur:0,totals:new Map(),results:[], unlimited:false, stats:new Map(), lastSit:new Set()};

function err(msg){ const e=$('#error'); e.textContent=msg; e.style.display='block'; }
function clearErr(){ const e=$('#error'); e.textContent=''; e.style.display='none'; }

/* Recreate the players textarea to guarantee it's editable */
function recreatePlayersTextarea(preserveText){
  const oldTa = document.getElementById('players');
  if(!oldTa) return null;
  const value = preserveText ? (oldTa.value || '').trim() : '';
  const newTa = document.createElement('textarea');
  newTa.id = 'players';
  newTa.placeholder = oldTa.placeholder || 'Players, one per line';
  newTa.value = value;
  newTa.style.pointerEvents = 'auto';
  newTa.disabled = false; newTa.readOnly = false;
  newTa.setAttribute('rows', oldTa.getAttribute('rows') || '10');
  oldTa.replaceWith(newTa);
  return newTa;
}

function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b, a%b]; } return a||1; }

/* ===== Stats recompute ===== */
function initStats(){
  state.totals = new Map(state.names.map(n=>[n,0]));
  state.stats = new Map(state.names.map(n=>[n, {w:0,d:0,l:0}]));
}
function recomputeFromResults(){
  initStats();
  for(let ri=0; ri<state.rounds.length; ri++){
    const res = state.results[ri];
    if(!res) continue;
    const round = state.rounds[ri];
    for(let mi=0; mi<round.matches.length; mi++){
      const m = round.matches[mi];
      const r = res[mi];
      if(!r) continue;
      for(const p of m.teamA){ state.totals.set(p, (state.totals.get(p)||0) + r.a); }
      for(const p of m.teamB){ state.totals.set(p, (state.totals.get(p)||0) + r.b); }
      if(r.a>r.b){ for(const p of m.teamA){ state.stats.get(p).w++; } for(const p of m.teamB){ state.stats.get(p).l++; } }
      else if(r.b>r.a){ for(const p of m.teamB){ state.stats.get(p).w++; } for(const p of m.teamA){ state.stats.get(p).l++; } }
      else { for(const p of m.teamA){ state.stats.get(p).d++; } for(const p of m.teamB){ state.stats.get(p).d++; } }
    }
  }
}

/* ===== UI builders ===== */
function buildScoreInputs(card, match){
  const teamALabel = match.teamA.join(' & ');
  const teamBLabel = match.teamB.join(' & ');
  const sc=document.createElement('div'); sc.className='score';

  const aLabel = document.createElement('span'); aLabel.textContent = teamALabel+':';
  const bLabel = document.createElement('span'); bLabel.textContent = teamBLabel+':';

  const aIn=document.createElement('input');
  aIn.type='number'; aIn.min='0'; aIn.step='1';
  aIn.placeholder=teamALabel; aIn.setAttribute('aria-label', teamALabel);
  aIn.setAttribute('inputmode','numeric'); aIn.setAttribute('pattern','[0-9]*');

  const bIn=document.createElement('input');
  bIn.type='number'; bIn.min='0'; bIn.step='1';
  bIn.placeholder=teamBLabel; bIn.setAttribute('aria-label', teamBLabel);
  bIn.setAttribute('inputmode','numeric'); bIn.setAttribute('pattern','[0-9]*');

  const blurOnEnter = (ev)=>{ if(ev.key==='Enter'){ ev.preventDefault(); ev.currentTarget.blur(); } };
  aIn.addEventListener('keydown', blurOnEnter);
  bIn.addEventListener('keydown', blurOnEnter);

  sc.append(aLabel,aIn,bLabel,bIn);
  card.appendChild(sc);

  function clamp(v){ v = Math.max(0, Math.min(state.points, Number(v)||0)); return Math.round(v); }
  let lock=false; function sync(src, dst){ if(lock) return; lock=true; const val=clamp(src.value); const oth=Math.max(0, state.points - val); dst.value=oth; lock=false; }
  aIn.addEventListener('input', ()=> sync(aIn, bIn)); bIn.addEventListener('input', ()=> sync(bIn, aIn));
  aIn.value='0'; bIn.value=String(state.points);
}
function renderSitInfo(sit){
  const el = $('#sitInfo');
  if(sit && sit.length){ el.textContent = 'Sit-out: ' + sit.join(', '); el.classList.remove('hidden'); }
  else { el.classList.add('hidden'); el.textContent=''; }
}

/* ===== Display a round ===== */
function showRound(i){
  state.cur=i; const r=state.rounds[i];
  if(!r){ err('Internal: round not found'); return; }
  $('#roundTitle').textContent=`Round ${i+1}`;
  $('#roundCount').textContent = state.unlimited ? `unlimited` : `of ${state.rounds.length}`;
  $('#pointsInfo').textContent = `to ${state.points} pts`;
  renderSitInfo(r.sit);
  const box=$('#matches'); box.innerHTML='';
  r.matches.forEach((m,idx)=>{
    const div=document.createElement('div'); div.className='match';
    div.innerHTML=`<b>Court ${idx+1}</b>: ${m.teamA.join(' & ')} vs ${m.teamB.join(' & ')}`;
    buildScoreInputs(div, m); box.appendChild(div);
  });
  $('#prev').disabled=(i===0);
  $('#next').disabled = (!state.unlimited && i>=state.rounds.length-1);
}

/* ===== Leaderboard ===== */
function updateLeaderboard(){
  const rows=state.names.map(n=>({name:n,rec:state.stats.get(n)||{w:0,d:0,l:0},pts:state.totals.get(n)||0}))
    .sort((a,b)=> b.pts-a.pts || a.name.localeCompare(b.name));
  $('#leader').innerHTML='<tr><th>#</th><th>Player</th><th class="muted">Record</th><th>Points</th></tr>' +
    rows.map((r,i)=>`<tr><td>${i+1}</td><td>${r.name}</td><td>W:${r.rec.w} D:${r.rec.d} L:${r.rec.l}</td><td>${r.pts}</td></tr>`).join('');
}

/* ===== Views ===== */
function showLeaderboardView(){
  document.getElementById('roundCard').classList.add('hidden');
  document.getElementById('leaderCard').classList.remove('hidden');
}
$('#btnLeaderboard').addEventListener('click', showLeaderboardView);
$('#closeLeader').addEventListener('click',()=>{
  document.getElementById('leaderCard').classList.add('hidden');
  document.getElementById('roundCard').classList.remove('hidden');
});

/* ===== Equal rounds picker ===== */
function computeEqualOptions(nPlayers, courts){
  const capacity = 4 * courts; // players per round
  if(nPlayers<4 || capacity<4) return {base:0, options:[], capacity};
  const base = Math.floor(nPlayers / gcd(nPlayers, capacity)); // minimal equal rounds
  const options=[]; for(let k=1;k<=6;k++) options.push(base*k);
  return {base, options, capacity};
}
function refreshEqualOptions(){
  const names = ($('#players')?.value || '').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const courts = +($('#courts')?.value || 2);
  const {base, options, capacity} = computeEqualOptions(names.length, courts);
  const sel = $('#equalRounds'); const note = $('#equalNote');
  sel.innerHTML='';
  if(options.length===0){ note.textContent='Enter players & courts to see valid equal round counts.'; return; }
  for(const r of options){
    const plays = (capacity * r) / names.length;
    const sits = r - plays;
    const opt = document.createElement('option');
    opt.value = String(r);
    opt.textContent = `${r} rounds — each plays ${plays}, sits ${sits}`;
    sel.appendChild(opt);
  }
  const plays0 = (capacity * options[0]) / names.length;
  const sits0 = options[0] - plays0;
  note.textContent = `${names.length} players, ${courts} courts ⇒ ${capacity}/round. Minimal equal: ${base} (each plays ${plays0}, sits ${sits0}).`;
}

/* ===== Balanced equal scheduler (guarantees equal totals, avoids back-to-back sits) ===== */
function buildBalancedEqualSchedule(names, courts, totalRounds){
  const capacity = 4 * courts;               // players per round
  const sitPerRound = names.length - capacity;
  if(sitPerRound < 0) throw new Error('More courts than players.');
  if(sitPerRound === 0) throw new Error('No sit-outs — use Auto/Custom mode.');

  const targetPlays = (capacity * totalRounds) / names.length;
  if(targetPlays !== Math.round(targetPlays)) throw new Error('Round count not equal-distributable.');

  // Track remaining sits and last sit list to prevent back-to-back
  const remSit = new Map(names.map(n=>[n, totalRounds - targetPlays]));
  let lastSit = new Set(); // players who sat last round

  const rounds = [];

  function chooseSitters(){
    // Sort by: remaining sits desc, (not sat last time) first, random tiebreak
    const arr = names.slice().sort((a,b)=>{
      const rsA = remSit.get(a), rsB = remSit.get(b);
      if(rsB !== rsA) return rsB - rsA;
      const penA = lastSit.has(a) ? 1 : 0;
      const penB = lastSit.has(b) ? 1 : 0;
      if(penA !== penB) return penA - penB; // prefer those NOT in lastSit
      return Math.random() - 0.5;
    });
    const pick = [];
    for(const p of arr){
      if(pick.length >= sitPerRound) break;
      if(remSit.get(p) > 0 && !pick.includes(p)){
        // If we can avoid consecutive sit, do it; otherwise, only allow if forced at the very end
        if(lastSit.has(p)){
          // Check if there are enough non-lastSit players with sits remaining
          const othersAvailable = arr.filter(x=>!lastSit.has(x) && remSit.get(x)>0 && !pick.includes(x));
          if(othersAvailable.length >= (sitPerRound - pick.length)) continue; // we can avoid picking p
        }
        pick.push(p);
      }
    }
    // Safety: if still not enough (shouldn’t happen), fill with any players not yet picked, minimizing repeats
    if(pick.length < sitPerRound){
      for(const p of names){
        if(pick.length >= sitPerRound) break;
        if(!pick.includes(p) && (remSit.get(p)>0)){
          pick.push(p);
        }
      }
    }
    return pick;
  }

  function pairUp(list){
    // Make 2-person teams, then make matches: [pair0 vs pair1], [pair2 vs pair3], ...
    const pool = list.slice();
    shuffle(pool);
    const pairs = [];
    for(let i=0;i<pool.length;i+=2) pairs.push([pool[i], pool[i+1]]);
    const matches = [];
    for(let i=0;i<pairs.length;i+=2){
      matches.push({ teamA: pairs[i], teamB: pairs[i+1] });
    }
    return matches;
  }

  for(let r=0;r<totalRounds;r++){
    const sitters = chooseSitters();
    sitters.forEach(p=> remSit.set(p, remSit.get(p)-1));
    const active = names.filter(n=>!sitters.includes(n));
    const matches = pairUp(active);
    rounds.push({ matches, sit: sitters });
    lastSit = new Set(sitters);
  }
  // Final assert: everyone used exactly targetPlays
  // (equivalently, remSit is zero for all)
  for(const [p,rs] of remSit.entries()){
    if(rs !== 0) throw new Error('Internal: imbalance after scheduling.');
  }
  return rounds;
}

/* ===== Setup interactions ===== */
$('#roundsMode').addEventListener('change',()=>{
  const mode=$('#roundsMode').value;
  $('#customRoundsWrap').classList.toggle('hidden', mode!=='custom');
  $('#equalWrap').classList.toggle('hidden', mode!=='equal');
  if(mode==='equal') refreshEqualOptions();
});
['input','change'].forEach(evt=>{
  $('#players').addEventListener(evt, ()=>{ if($('#roundsMode').value==='equal') refreshEqualOptions(); });
  $('#courts').addEventListener(evt, ()=>{ if($('#roundsMode').value==='equal') refreshEqualOptions(); });
});

$('#start').addEventListener('click',()=>{
  try{
    clearErr();
    const raw = $('#players').value;
    const names=raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    if(names.length<4){ alert('Need at least 4 players'); return; }
    state.names=names; state.courts=+$('#courts').value; state.points=+$('#points').value;
    state.results=[]; initStats();
    state.lastSit = new Set();

    const mode=$('#roundsMode').value; state.unlimited = (mode==='unlimited');
    let rounds=[];

    if(mode==='equal'){
      const target = +($('#equalRounds').value||0);
      if(!target){ alert('Pick an equal round count.'); return; }
      rounds = buildBalancedEqualSchedule(names, state.courts, target);
    }else{
      // Fallback: simple fair generator (not strictly equal unless you pick an equal count)
      // Create random rounds filling all courts from the roster, avoiding consecutive sits.
      const totalRounds = (mode==='auto')
        ? ((names.length%2===1)? names.length : (names.length-1))
        : (mode==='custom' ? (+$('#customRounds').value||1) : 20); // some default for unlimited start
      const sitPerRound = names.length - 4*state.courts;
      let lastSit = new Set();
      const playQuota = new Map(names.map(n=>[n,0]));
      for(let r=0;r<totalRounds;r++){
        // choose sitters (heuristic)
        const arr = names.slice().sort((a,b)=>{
          // prefer those who have played more to sit
          const pa=playQuota.get(a), pb=playQuota.get(b);
          if(pa!==pb) return pb-pa;
          const penA = lastSit.has(a)?1:0, penB = lastSit.has(b)?1:0;
          if(penA!==penB) return penA-penB;
          return Math.random()-0.5;
        });
        const sitters=[]; for(const p of arr){ if(sitters.length>=sitPerRound) break; if(!sitters.includes(p)) sitters.push(p); }
        const active=names.filter(n=>!sitters.includes(n));
        shuffle(active);
        const pairs=[]; for(let i=0;i<active.length;i+=2) pairs.push([active[i],active[i+1]]);
        const matches=[]; for(let i=0;i<pairs.length;i+=2) matches.push({teamA:pairs[i], teamB:pairs[i+1]});
        active.forEach(p=> playQuota.set(p, playQuota.get(p)+1));
        rounds.push({matches, sit:sitters});
        lastSit = new Set(sitters);
      }
    }

    if(!rounds.length){ err('No rounds generated'); return; }

    state.rounds=rounds;
    document.getElementById('setupCard').classList.add('hidden');
    document.getElementById('roundCard').classList.remove('hidden');
    document.getElementById('leaderCard').classList.add('hidden');
    document.getElementById('btnLeaderboard').disabled=false;
    document.getElementById('status').textContent='live';
    showRound(0); updateLeaderboard();
  }catch(e){ console.error(e); err('Start error: '+(e.message||e)); }
});

/* ===== Round nav ===== */
$('#prev').addEventListener('click',()=>{ if(state.cur>0) showRound(state.cur-1); });
$('#next').addEventListener('click',()=>{ if(state.cur<state.rounds.length-1) showRound(state.cur+1); });

/* ===== Submit scores ===== */
$('#submit').addEventListener('click',()=>{
  try{
    const r=state.rounds[state.cur]; const cards=$$('#matches .match'); const scores=[];
    for(const [idx,card] of cards.entries()){
      const ins=card.querySelectorAll('input');
      const a=+ins[0].value, b=+ins[1].value;
      if(a+b!==state.points){ alert('Each match must sum to '+state.points); return; }
      scores.push({a,b});
    }
    state.results[state.cur]=scores;
    recomputeFromResults();
    updateLeaderboard();

    const isLastRound = (!state.unlimited && state.cur >= state.rounds.length-1);
    if(isLastRound){
      showLeaderboardView();
      alert('All rounds completed!');
    }else{
      showRound(state.cur+1);
    }
  }catch(e){ console.error(e); err('Submit error: '+(e.message||e)); }
});

/* ===== Reset logic ===== */
function fullReset(){
  if(!confirm('Full reset and start over?')) return;
  state.names=[]; state.courts=2; state.points=24; state.rounds=[]; state.cur=0;
  state.totals=new Map(); state.results=[]; state.unlimited=false; state.stats=new Map(); state.lastSit = new Set();

  const ta = recreatePlayersTextarea(false);

  $('#courts').value=2; $('#points').value=24;
  $('#roundsMode').value='auto'; $('#customRounds').value=9; $('#customRoundsWrap').classList.add('hidden');
  $('#equalWrap').classList.add('hidden'); $('#equalRounds').innerHTML=''; $('#equalNote').textContent='';
  $('#matches').innerHTML=''; $('#leader').innerHTML='<tr><th>#</th><th>Player</th><th class="muted">Record</th><th>Points</th></tr>';

  document.getElementById('setupCard').classList.remove('hidden');
  document.getElementById('roundCard').classList.add('hidden');
  document.getElementById('leaderCard').classList.add('hidden');
  document.getElementById('btnLeaderboard').disabled=true;
  document.getElementById('status').textContent='ready';
  window.scrollTo(0,0);
  if(ta) ta.focus();
  clearErr();
}
function resetKeepPlayers(){
  if(!confirm('Reset event but keep players?')) return;

  const currentTa = document.getElementById('players');
  const preserved = (currentTa && currentTa.value) ? currentTa.value.trim() : '';

  state.names=[]; state.courts=2; state.points=24; state.rounds=[]; state.cur=0;
  state.totals=new Map(); state.results=[]; state.unlimited=false; state.stats=new Map(); state.lastSit = new Set();

  const ta = recreatePlayersTextarea(true);
  if(ta) ta.value = preserved;

  $('#courts').value=2; $('#points').value=24;
  $('#roundsMode').value='auto'; $('#customRounds').value=9; $('#customRoundsWrap').classList.add('hidden');
  $('#equalWrap').classList.add('hidden'); $('#equalRounds').innerHTML=''; $('#equalNote').textContent='';
  $('#matches').innerHTML=''; $('#leader').innerHTML='<tr><th>#</th><th>Player</th><th class="muted">Record</th><th>Points</th></tr>';

  document.getElementById('setupCard').classList.remove('hidden');
  document.getElementById('roundCard').classList.add('hidden');
  document.getElementById('leaderCard').classList.add('hidden');
  document.getElementById('btnLeaderboard').disabled=true;
  document.getElementById('status').textContent='ready';
  window.scrollTo(0,0);
  if(ta) ta.focus();
  clearErr();
}
$('#btnReset').addEventListener('click', fullReset);
$('#btnResetKeep').addEventListener('click', resetKeepPlayers);
</script>
</body>
</html>

