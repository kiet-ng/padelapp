<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- Prevent iOS auto-zoom; fit the notch; keep scale steady -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <title>Americano – Live Round & Leaderboard (v14)</title>
  <style>
    :root{ --bg:#0b0f14; --card:#0f172a; --border:#1f2937; --muted:#9aa4b2; --fg:#e7ecf3; }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
    html{-webkit-text-size-adjust:100%}
    .wrap{max-width:960px;margin:0 auto;padding:16px}
    .bar{position:sticky;top:0;background:rgba(11,15,20,.92);backdrop-filter:blur(8px);border-bottom:1px solid var(--border);z-index:10;
         padding-top:env(safe-area-inset-top)}
    .bar .wrap{display:flex;gap:10px;align-items:center}
    .pill{font-size:12px;color:var(--muted);border:1px solid var(--border);padding:4px 10px;border-radius:999px}
    .btn{display:inline-flex;align-items:center;gap:6px;padding:12px 16px;border-radius:12px;border:1px solid #334155;background:#22c55e;color:#0b1118;
         font-weight:700;cursor:pointer;touch-action:manipulation}
    .btn.ghost{background:var(--card);color:var(--fg);border-color:#334155}
    .btn.danger{background:#7f1d1d;border-color:#7f1d1d;color:#fecaca}
    .btn.alt{background:#f59e0b;border-color:#f59e0b;color:#111827}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:16px;margin:14px 0}
    label{display:block;margin:12px 0 6px;font-size:14px;color:var(--muted)}
    textarea,input,select{
      width:100%;padding:12px 12px;border-radius:10px;border:1px solid #334155;background:#0b1220;color:var(--fg);
      font-size:16px;line-height:1.2; -webkit-appearance:none; appearance:none;
    }
    textarea{min-height:120px;resize:vertical}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid #334155;padding:10px 8px;text-align:left}
    .hidden{display:none}
    #error{display:none;background:#3f1d20;border:1px solid #7f1d1d;color:#fecaca;border-radius:10px;padding:10px;margin-top:10px;white-space:pre-wrap}
    .tags{display:flex;gap:8px;flex-wrap:wrap}
    .muted{color:var(--muted)}
    .match{padding:12px;margin:12px 0;border:1px dashed #334155;border-radius:12px}
    .score{ display:grid;grid-template-columns:auto 1fr auto 1fr;gap:10px;align-items:center;margin-top:10px }
    .score input{ width:100%;max-width:140px;text-align:center;font-weight:700;padding:12px 10px }
    @media (max-width:520px){
      .wrap{padding:12px}
      .btn{padding:12px 14px}
      .score{grid-template-columns:1fr 1fr;grid-row-gap:8px}
      .score > :nth-child(1){grid-column:1;justify-self:start}
      .score > :nth-child(2){grid-column:2}
      .score > :nth-child(3){grid-column:1;justify-self:start}
      .score > :nth-child(4){grid-column:2}
    }
  </style>
  <script>
    window.addEventListener('error', e => {
      const box = document.getElementById('error');
      if(!box) return;
      box.style.display = 'block';
      box.textContent = 'JS error: ' + (e.message || e.error || 'unknown');
    });
  </script>
</head>
<body>
  <div class="bar">
    <div class="wrap">
      <h2 style="margin:0">Kiet's Americano App</h2>
      <span class="pill" id="status">ready</span>
      <div style="flex:1"></div>
      <button id="btnLeaderboard" class="btn ghost" disabled>Leaderboard</button>
      <button id="btnResetKeep" class="btn alt">Reset (keep players)</button>
      <button id="btnReset" class="btn danger">Reset</button>
    </div>
  </div>

  <div class="wrap">
    <div id="error"></div>

    <div id="setupCard" class="card">
      <h3>Setup</h3>
      <label>Players (one per line)</label>
      <textarea id="players" placeholder="Alice&#10;Bjørn&#10;Carla&#10;David&#10;Emma&#10;Filip&#10;Grete&#10;Henrik&#10;Iris"></textarea>

      <label>Courts</label>
      <input id="courts" type="number" value="2" min="1" inputmode="numeric" />

      <label>Points per match</label>
      <select id="points">
          <option value="16">16</option>
  	<option value="20">20</option>
  	<option value="24" selected>24</option>
  	<option value="32">32</option>
      </select>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px">
        <div>
          <label>Total rounds mode</label>
          <select id="roundsMode">
            <option value="auto" selected>Auto (full cycle)</option>
            <option value="equal">Equal (balanced)</option>
            <option value="custom">Custom number</option>
            <option value="unlimited">Unlimited</option>
          </select>
        </div>
        <div id="equalWrap" class="hidden">
          <label>Equal round count</label>
          <select id="equalRounds"></select>
          <div id="equalNote" class="muted" style="font-size:13px;margin-top:6px"></div>
        </div>
        <div id="customRoundsWrap" class="hidden">
          <label>Total rounds (custom)</label>
          <input id="customRounds" type="number" min="1" value="9" inputmode="numeric" />
        </div>
      </div>

      <button class="btn" id="start" style="margin-top:14px">Start event</button>
    </div>

    <div id="roundCard" class="card hidden">
      <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
        <h3 id="roundTitle" style="margin:0">Round</h3>
        <div class="tags">
          <span class="pill" id="roundCount"></span>
          <span class="pill" id="pointsInfo"></span>
          <span class="pill hidden" id="sitInfo"></span>
        </div>
        <div style="flex:1"></div>
        <button class="btn ghost" id="prev">◀ Prev</button>
        <button class="btn ghost" id="next">Next ▶</button>
      </div>
      <div id="matches"></div>
      <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:10px">
        <button class="btn" id="submit">Submit round scores</button>
      </div>
    </div>

    <div id="leaderCard" class="card hidden">
      <div style="display:flex;align-items:center;gap:10px">
        <h3 style="margin:0">Leaderboard</h3>
        <div style="flex:1"></div>
        <button class="btn ghost" id="closeLeader">Back to round</button>
      </div>
      <table id="leader"><tr><th>#</th><th>Player</th><th class="muted">Record</th><th>Points</th></tr></table>
    </div>
  </div>

<script>
const $=s=>document.querySelector(s); const $$=s=>Array.from(document.querySelectorAll(s));
const state={names:[],courts:2,points:24,rounds:[],cur:0,totals:new Map(),results:[], unlimited:false, stats:new Map(), lastSit:new Set()};

function err(msg){ const e=$('#error'); e.textContent=msg; e.style.display='block'; }
function clearErr(){ const e=$('#error'); e.textContent=''; e.style.display='none'; }

/* Recreate the players textarea to guarantee it's editable */
function recreatePlayersTextarea(preserveText){
  const oldTa = document.getElementById('players');
  if(!oldTa) return null;
  const value = preserveText ? (oldTa.value || '').trim() : '';
  const newTa = document.createElement('textarea');
  newTa.id = 'players';
  newTa.placeholder = oldTa.placeholder || 'Players, one per line';
  newTa.value = value;
  newTa.style.pointerEvents = 'auto';
  newTa.disabled = false; newTa.readOnly = false;
  newTa.setAttribute('rows', oldTa.getAttribute('rows') || '10');
  oldTa.replaceWith(newTa);
  return newTa;
}

function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b, a%b]; } return a||1; }

/* Round-robin pairings (with BYE when odd) */
function pairings(names){
  const BYE='__BYE__';
  const list=[...names];
  if(list.length%2===1) list.push(BYE);
  const n=list.length; let idx=list.map((_,i)=>i); const rounds=[];
  for(let r=0;r<n-1;r++){
    const pairs=[]; const byes=[];
    for(let i=0;i<n/2;i++){
      const A=list[idx[i]], B=list[idx[n-1-i]];
      if(A===BYE) byes.push(B); else if(B===BYE) byes.push(A); else pairs.push([A,B]);
    }
    rounds.push({pairs, byes});
    idx=[idx[0], idx[n-1], ...idx.slice(1,n-1)];
  }
  return rounds;
}

/* Choose up to (courts*2) pairs for a sub-round to minimize overlap with prevSit */
function chooseChunkMinSitOverlap(pairsLeft, takePairs, prevSit){
  // Try several shuffles to find a good chunk
  let best=null, bestPenalty=Infinity, bestUsedIdx=null;
  for(let attempt=0; attempt<40; attempt++){
    const order = pairsLeft.map((_,i)=>i);
    shuffle(order);
    const chosenIdx = order.slice(0, takePairs);
    // Build matches
    const matches=[], usedPlayers=new Set();
    for(let k=0; k<chosenIdx.length; k+=2){
      const p1=pairsLeft[chosenIdx[k]], p2=pairsLeft[chosenIdx[k+1]];
      if(!p2) break; // need 2 pairs per match
      matches.push({teamA:p1, teamB:p2});
      p1.forEach(x=>usedPlayers.add(x));
      p2.forEach(x=>usedPlayers.add(x));
    }
    if(matches.length===0) continue;
    // Compute sit for this base-round’s players (we pass it in at caller)
    // Here we just compute the penalty = overlap with prevSit
    let penalty=0;
    for(const s of prevSit){ if(!usedPlayers.has(s)) penalty++; } // players in prevSit that are still sitting now
    if(penalty < bestPenalty){ best={matches, usedPlayers}; bestPenalty=penalty; bestUsedIdx=chosenIdx; if(penalty===0) break; }
  }
  if(!best) return null;
  // Remove used pairs by index (descending so splice doesn't shift earlier ones)
  bestUsedIdx.sort((a,b)=>b-a).forEach(idx=>pairsLeft.splice(idx,1));
  return best;
}

/* Build sub-rounds; skip empty ones; compute sit-outs; avoid consecutive sits where possible */
function packRoundsNoConsecutive(rr,courts, prevSitGlobal){
  const subs=[]; let lastSit = new Set(prevSitGlobal||[]);
  for(const R of rr){
    const pairsLeft = shuffle(R.pairs.slice());
    const allPlayers = new Set(pairsLeft.flat().filter(x=>x!=='__BYE__'));
    const takePairs = courts*2; // pairs needed to fill all courts this sub-round
    while(pairsLeft.length>0){
      const choice = chooseChunkMinSitOverlap(pairsLeft, takePairs, lastSit);
      if(!choice){ break; }
      const {matches, usedPlayers} = choice;
      if(matches.length===0) continue;
      const sit = [...allPlayers].filter(p=>!usedPlayers.has(p));
      subs.push({matches, sit});
      lastSit = new Set(sit); // update for next sub-round (across entire schedule)
    }
  }
  return {subs, lastSit};
}

function idealRounds(n){ return (n%2===1)? n : (n-1); } // full cycle default

function initStats(){
  state.totals = new Map(state.names.map(n=>[n,0]));
  state.stats = new Map(state.names.map(n=>[n, {w:0,d:0,l:0}]));
}

function recomputeFromResults(){
  initStats();
  for(let ri=0; ri<state.rounds.length; ri++){
    const res = state.results[ri];
    if(!res) continue;
    const round = state.rounds[ri];
    for(let mi=0; mi<round.matches.length; mi++){
      const m = round.matches[mi];
      const r = res[mi];
      if(!r) continue;
      for(const p of m.teamA){ state.totals.set(p, (state.totals.get(p)||0) + r.a); }
      for(const p of m.teamB){ state.totals.set(p, (state.totals.get(p)||0) + r.b); }
      if(r.a>r.b){ for(const p of m.teamA){ state.stats.get(p).w++; } for(const p of m.teamB){ state.stats.get(p).l++; } }
      else if(r.b>r.a){ for(const p of m.teamB){ state.stats.get(p).w++; } for(const p of m.teamA){ state.stats.get(p).l++; } }
      else { for(const p of m.teamA){ state.stats.get(p).d++; } for(const p of m.teamB){ state.stats.get(p).d++; } }
    }
  }
}

/* Build score inputs (mobile friendly) */
function buildScoreInputs(card, match){
  const teamALabel = match.teamA.join(' & ');
  const teamBLabel = match.teamB.join(' & ');
  const sc=document.createElement('div'); sc.className='score';

  const aLabel = document.createElement('span'); aLabel.textContent = teamALabel+':';
  const bLabel = document.createElement('span'); bLabel.textContent = teamBLabel+':';

  const aIn=document.createElement('input');
  aIn.type='number'; aIn.min='0'; aIn.step='1';
  aIn.placeholder=teamALabel; aIn.setAttribute('aria-label', teamALabel);
  aIn.setAttribute('inputmode','numeric'); aIn.setAttribute('pattern','[0-9]*');

  const bIn=document.createElement('input');
  bIn.type='number'; bIn.min='0'; bIn.step='1';
  bIn.placeholder=teamBLabel; bIn.setAttribute('aria-label', teamBLabel);
  bIn.setAttribute('inputmode','numeric'); bIn.setAttribute('pattern','[0-9]*');

  const blurOnEnter = (ev)=>{ if(ev.key==='Enter'){ ev.preventDefault(); ev.currentTarget.blur(); } };
  aIn.addEventListener('keydown', blurOnEnter);
  bIn.addEventListener('keydown', blurOnEnter);

  sc.append(aLabel,aIn,bLabel,bIn);
  card.appendChild(sc);

  function clamp(v){ v = Math.max(0, Math.min(state.points, Number(v)||0)); return Math.round(v); }
  let lock=false; function sync(src, dst){ if(lock) return; lock=true; const val=clamp(src.value); const oth=Math.max(0, state.points - val); dst.value=oth; lock=false; }
  aIn.addEventListener('input', ()=> sync(aIn, bIn)); bIn.addEventListener('input', ()=> sync(bIn, aIn));
  aIn.value='0'; bIn.value=String(state.points);
}

function renderSitInfo(sit){
  const el = $('#sitInfo');
  if(sit && sit.length){ el.textContent = 'Sit-out: ' + sit.join(', '); el.classList.remove('hidden'); }
  else { el.classList.add('hidden'); el.textContent=''; }
}

function showRound(i){
  if(state.unlimited && i>=state.rounds.length){
    // Generate more rounds continuing the no-consecutive-sit constraint
    const rr=pairings(state.names);
    const {subs, lastSit} = packRoundsNoConsecutive(rr, state.courts, state.lastSit);
    state.rounds = state.rounds.concat(subs);
    state.lastSit = lastSit;
  }
  state.cur=i; const r=state.rounds[i];
  if(!r){ err('Internal: round not found'); return; }
  $('#roundTitle').textContent=`Round ${i+1}`;
  $('#roundCount').textContent = state.unlimited ? `unlimited` : `of ${state.rounds.length}`;
  $('#pointsInfo').textContent = `to ${state.points} pts`;
  renderSitInfo(r.sit);
  const box=$('#matches'); box.innerHTML='';
  r.matches.forEach((m,idx)=>{
    const div=document.createElement('div'); div.className='match';
    div.innerHTML=`<b>Court ${idx+1}</b>: ${m.teamA.join(' & ')} vs ${m.teamB.join(' & ')}`;
    buildScoreInputs(div, m); box.appendChild(div);
  });
  $('#prev').disabled=(i===0);
  $('#next').disabled=false;
  if(!state.unlimited){ $('#next').disabled = (i>=state.rounds.length-1); }
}

function updateLeaderboard(){
  const rows=state.names.map(n=>({name:n,rec:state.stats.get(n)||{w:0,d:0,l:0},pts:state.totals.get(n)||0}))
    .sort((a,b)=> b.pts-a.pts || a.name.localeCompare(b.name));
  $('#leader').innerHTML='<tr><th>#</th><th>Player</th><th class="muted">Record</th><th>Points</th></tr>' +
    rows.map((r,i)=>`<tr><td>${i+1}</td><td>${r.name}</td><td>W:${r.rec.w} D:${r.rec.d} L:${r.rec.l}</td><td>${r.pts}</td></tr>`).join('');
}

/* --- View switches --- */
function showLeaderboardView(){
  document.getElementById('roundCard').classList.add('hidden');
  document.getElementById('leaderCard').classList.remove('hidden');
}
$('#btnLeaderboard').addEventListener('click', showLeaderboardView);
$('#closeLeader').addEventListener('click',()=>{
  document.getElementById('leaderCard').classList.add('hidden');
  document.getElementById('roundCard').classList.remove('hidden');
});

/* ==== Equal rounds UX ==== */
function computeEqualOptions(nPlayers, courts){
  const capacity = 4 * courts;
  if(nPlayers<4 || capacity<4) return {base:0, options:[], capacity};
  const base = Math.floor(nPlayers / gcd(nPlayers, capacity)); // minimal equal rounds
  const options=[]; for(let k=1;k<=6;k++) options.push(base*k);
  return {base, options, capacity};
}
function refreshEqualOptions(){
  const names = ($('#players')?.value || '').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const courts = +($('#courts')?.value || 2);
  const {base, options, capacity} = computeEqualOptions(names.length, courts);
  const sel = $('#equalRounds'); const note = $('#equalNote');
  sel.innerHTML='';
  if(options.length===0){ note.textContent='Enter players & courts to see valid equal round counts.'; return; }
  for(const r of options){
    const plays = (capacity * r) / names.length;
    const sits = r - plays;
    const opt = document.createElement('option');
    opt.value = String(r);
    opt.textContent = `${r} rounds — each plays ${plays}, sits ${sits}`;
    sel.appendChild(opt);
  }
  const plays0 = (capacity * options[0]) / names.length;
  const sits0 = options[0] - plays0;
  note.textContent = `${names.length} players, ${courts} courts ⇒ ${capacity}/round. Minimal equal: ${base} (each plays ${plays0}, sits ${sits0}).`;
}

/* --- Setup interactions --- */
$('#roundsMode').addEventListener('change',()=>{
  const mode=$('#roundsMode').value;
  $('#customRoundsWrap').classList.toggle('hidden', mode!=='custom');
  $('#equalWrap').classList.toggle('hidden', mode!=='equal');
  if(mode==='equal') refreshEqualOptions();
});
['input','change'].forEach(evt=>{
  $('#players').addEventListener(evt, ()=>{ if($('#roundsMode').value==='equal') refreshEqualOptions(); });
  $('#courts').addEventListener(evt, ()=>{ if($('#roundsMode').value==='equal') refreshEqualOptions(); });
});

$('#start').addEventListener('click',()=>{
  try{
    clearErr();
    const raw = $('#players').value;
    const names=raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    if(names.length<4){ alert('Need at least 4 players'); return; }
    state.names=names; state.courts=+$('#courts').value; state.points=+$('#points').value;
    state.results=[]; initStats();
    state.lastSit = new Set(); // reset sit-tracker

    const rr=pairings(names);
    let built = packRoundsNoConsecutive(rr, state.courts, state.lastSit);
    let rounds = built.subs; state.lastSit = built.lastSit;

    const mode=$('#roundsMode').value; state.unlimited = (mode==='unlimited');

    if(mode==='auto'){
      const full=idealRounds(names.length);
      if(rounds.length>full) rounds=rounds.slice(0,full);
    } else if(mode==='custom'){
      const n=+$('#customRounds').value||1;
      if(rounds.length>n) rounds=rounds.slice(0,n);
      else { while(rounds.length<n){ const extra=packRoundsNoConsecutive(pairings(names), state.courts, state.lastSit); rounds=rounds.concat(extra.subs); state.lastSit = extra.lastSit; } rounds=rounds.slice(0,n); }
    } else if(mode==='equal'){
      const target = +($('#equalRounds').value||0);
      if(!target){ alert('Pick an equal round count.'); return; }
      if(rounds.length>target) rounds=rounds.slice(0,target);
      else { while(rounds.length<target){ const extra=packRoundsNoConsecutive(pairings(names), state.courts, state.lastSit); rounds=rounds.concat(extra.subs); state.lastSit = extra.lastSit; } rounds=rounds.slice(0,target); }
    }

    if(!rounds.length){ err('No rounds generated'); return; }

    state.rounds=rounds;
    document.getElementById('setupCard').classList.add('hidden');
    document.getElementById('roundCard').classList.remove('hidden');
    document.getElementById('leaderCard').classList.add('hidden');
    document.getElementById('btnLeaderboard').disabled=false;
    document.getElementById('status').textContent='live';
    showRound(0); updateLeaderboard();
  }catch(e){ console.error(e); err('Start error: '+(e.message||e)); }
});

/* --- Round nav --- */
$('#prev').addEventListener('click',()=>{ if(state.cur>0) showRound(state.cur-1); });
$('#next').addEventListener('click',()=>{ showRound(state.cur+1); });

/* --- Submit scores: next immediately; auto-show leaderboard ONLY on last round --- */
$('#submit').addEventListener('click',()=>{
  try{
    const r=state.rounds[state.cur]; const cards=$$('#matches .match'); const scores=[];
    for(const [idx,card] of cards.entries()){
      const ins=card.querySelectorAll('input');
      const a=+ins[0].value, b=+ins[1].value;
      if(a+b!==state.points){ alert('Each match must sum to '+state.points); return; }
      scores.push({a,b});
    }
    state.results[state.cur]=scores;
    recomputeFromResults();
    updateLeaderboard();

    const isLastRound = (!state.unlimited && state.cur >= state.rounds.length-1);
    if(isLastRound){
      showLeaderboardView();
      alert('All rounds completed!');
    }else{
      showRound(state.cur+1);
    }
  }catch(e){ console.error(e); err('Submit error: '+(e.message||e)); }
});

/* --- Reset logic: replace the textarea to guarantee editability --- */
function fullReset(){
  if(!confirm('Full reset and start over?')) return;
  state.names=[]; state.courts=2; state.points=24; state.rounds=[]; state.cur=0;
  state.totals=new Map(); state.results=[]; state.unlimited=false; state.stats=new Map(); state.lastSit = new Set();

  const ta = recreatePlayersTextarea(false);

  $('#courts').value=2; $('#points').value=24;
  $('#roundsMode').value='auto'; $('#customRounds').value=9; $('#customRoundsWrap').classList.add('hidden');
  $('#equalWrap').classList.add('hidden'); $('#equalRounds').innerHTML=''; $('#equalNote').textContent='';
  $('#matches').innerHTML=''; $('#leader').innerHTML='<tr><th>#</th><th>Player</th><th class="muted">Record</th><th>Points</th></tr>';

  document.getElementById('setupCard').classList.remove('hidden');
  document.getElementById('roundCard').classList.add('hidden');
  document.getElementById('leaderCard').classList.add('hidden');
  document.getElementById('btnLeaderboard').disabled=true;
  document.getElementById('status').textContent='ready';
  window.scrollTo(0,0);
  if(ta) ta.focus();
  clearErr();
}

function resetKeepPlayers(){
  if(!confirm('Reset event but keep players?')) return;

  const currentTa = document.getElementById('players');
  const preserved = (currentTa && currentTa.value) ? currentTa.value.trim() : '';

  state.names=[]; state.courts=2; state.points=24; state.rounds=[]; state.cur=0;
  state.totals=new Map(); state.results=[]; state.unlimited=false; state.stats=new Map(); state.lastSit = new Set();

  const ta = recreatePlayersTextarea(true);
  if(ta) ta.value = preserved;

  $('#courts').value=2; $('#points').value=24;
  $('#roundsMode').value='auto'; $('#customRounds').value=9; $('#customRoundsWrap').classList.add('hidden');
  $('#equalWrap').classList.add('hidden'); $('#equalRounds').innerHTML=''; $('#equalNote').textContent='';
  $('#matches').innerHTML=''; $('#leader').innerHTML='<tr><th>#</th><th>Player</th><th class="muted">Record</th><th>Points</th></tr>';

  document.getElementById('setupCard').classList.remove('hidden');
  document.getElementById('roundCard').classList.add('hidden');
  document.getElementById('leaderCard').classList.add('hidden');
  document.getElementById('btnLeaderboard').disabled=true;
  document.getElementById('status').textContent='ready';
  window.scrollTo(0,0);
  if(ta) ta.focus();
  clearErr();
}
$('#btnReset').addEventListener('click', fullReset);
$('#btnResetKeep').addEventListener('click', resetKeepPlayers);
</script>
</body>
</html>
